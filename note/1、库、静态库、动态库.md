## 1、库

程序编译成可执行程序的过程：

![image-20220817101041425](https://gitee.com/czjaixuexi/typora_pictures/raw/master/img/image-20220817101041425.png)

- 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用

- 者一些可以直接拿来用的变量、函数或类。

- 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。

- 库的好处：

  - 1.代码保密 ，C++的反编译解密程度比较低

  - 2.方便部署和分发

## 2、静态库

静态库在程序的链接阶段被复制到了程序中。

![image-20220817101055729](https://gitee.com/czjaixuexi/typora_pictures/raw/master/img/image-20220817101055729.png)

#### 静态库的制作：

##### 静态库的命名规则：

- Linux : **libxxx.a**
  - lib : 前缀（固定）
  - xxx : 库的名字，自己起
  - .a :后缀(固定)

- Windows : **libxxx.lib**

##### 静态库的制作方法:

- gcc -c(编译但不链接）获得.o文件
- 将.o文件使用ar工具(archive)打包

​		**ar rcs libxxx.a xxx.o xxx.o**

```Linux
r - 将文件插入备存文件中
c - 建立备存文件
s - 索引
```

#### 静态库的使用方法：

在要编译的文件中，使用-I 指定头文件目录，-L ，-I指令搜索对应文件夹下的库和文件，正确编译文件

```Linux
gcc main.c -o app -I ./include/ -l calc -L lib/
```



## 3、动态库

动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。

![image-20220817101110743](https://gitee.com/czjaixuexi/typora_pictures/raw/master/img/image-20220817101110743.png)

#### 动态库的制作：

##### 动态库的命名规则：

- Linux : **libxxx.so**
  - lib : 前缀（固定）
  - xxx : 库的名字，自己起
  - .so : 后缀（固定）
  - 在Linux下是一个可执行文件
-  Windows : **libxxx.dll**

##### 动态库的制作方法：

- gcc 得到 .o 文件，得到和位置无关的代码

  ```Linux
  gcc -c –fpic/-fPIC a.c b.c
  ```

-  gcc 得到动态库

  ```Linux
  gcc -shared a.o b.o -o libcalc.so
  ```

  

  #### 动态库的使用方法：

  在要编译的文件中，使用-I 指定头文件目录，-L ，-I指令搜索对应文件夹下的库和文件，正确编译文件

  ```Linux
  gcc main.c -o app -I ./include/ -l calc -L lib/
  ```

仅执行以上操作，会提示动态库加载失败。

动态库在Linux下是一个可执行文件，只有在程序运行时，动态库会加载在内存中，动态的装载在程序中，相较于静态库，整个执行的过程变得更加的复杂了，因此，如果不注意，动态库的加载就会出现问题。

##### 加载失败的原因：

- 动态库文件和头文件都需要打包给用户
- 编译时需要指明动态库的绝对路径
- 动态库没有写入在内存中，程序运行时，找不到动态库



##### 如何定位共享库文件呢？

当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路

径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是

由ld-linux.so来完成的，它先后搜索elf文件的 **DT_RPATH段** ——> **环境变量**

**LD_LIBRARY_PATH** ——> **/etc/ld.so.cache**文件列表 ——> **/lib/**，**/usr/lib**

目录找到库文件后将其载入内存。



##### 找不到动态的解决办法：

###### 1.配置环境变量解决

1. （临时解决方案）直接在执行文件的目录下，输入：

   ```C++
   exportLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/czj/Linux/lesson06/library/lib  //PATH后面的内容为动态库的路径
   ```

   将编译好的动态库的路径，加入在系统的LD_LIBRARY_PATH环境变量中，即可解决。

   - 缺点是，该操作是临时的，重新打开终端将失效

2. （用户级解决方案）通过home目录下的.bashrc文件 在末尾添加：

   ```C++
   exportLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/czj/Linux/lesson06/library/lib  //PATH后面的内容为动态库的路径
   ```

   然后输入：`. .bashrc`更新文件。

3. （系统级解决方案）输入`sudo vim /etc/profile` 打开该文件，在末尾添加：

   ```C++
   exportLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/czj/Linux/lesson06/library/lib  //PATH后面的内容为动态库的路径
   ```

    然后输入：`. /etc/profile`更新文件。



###### 2.修改/etc/ld.so.cache文件列表

​	输入：`sudo vim /etc/ld.so.conf`打开文件在文件末尾粘贴动态库的文件路径，保存后退出

​	再输入：`sudo ldconfig`更新文件



###### 3.将动态库文件放入`/lib/`  或者`/usr/lib`目录下（不建议使用）

​	系统的库文件存放于此，可能会影响系统的库文件。

## 4、静态库和动态库的对比

- 静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中
- 动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中，程序启动之后，动态库会被动态加载到内存中，通过 ldd （list dynamic dependencies）命令检查动态库依赖关系

##### 静态库的优缺点：

|                优点                |          缺点          |
| :--------------------------------: | :--------------------: |
| 静态库被打包到应用程序中加载速度快 | 消耗系统资源，浪费内存 |
|  发布程序无需提供静态库，移植方便  |  更新、部署、发布麻烦  |

![image-20220817101128023](https://gitee.com/czjaixuexi/typora_pictures/raw/master/img/image-20220817101128023.png)

##### 动态库的优缺点：

|               优点               |              缺点              |
| :------------------------------: | :----------------------------: |
| 可以实现进程间资源共享（共享库） |       加载速度比静态库慢       |
|       更新、部署、发布简单       | 发布程序时需要提供依赖的动态库 |
|      可以控制何时加载动态库      |                                |

![image-20220817101139057](https://gitee.com/czjaixuexi/typora_pictures/raw/master/img/image-20220817101139057.png)



总得来说：

从产品化的角度，发布的算法库或功能库**尽量使动态库**，这样方便更新和升级，不必重新编译整个可执行文件，只需新版本动态库替换掉旧动态库即可。

从函数库集成的角度，若要将发布的所有子库（不止一个）集成为一个动态库向外提供接口，那么就需要将所有子库编译为静态库，这样所有子库就可以全部编译进目标动态库中，由最终的一个集成库向外提供功能。

